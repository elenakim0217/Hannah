<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hannah Human Protocol</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/wanteddev/wanted-sans@v1.0.1/packages/wanted-sans/fonts/webfonts/variable/split/WantedSansVariable.min.css');

        /* [1. 화면 전체 설정] */
        body {
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            background-color: #333; 
            overflow: hidden;
            font-family: 'Wanted Sans Variable', -apple-system, sans-serif;
            user-select: none; 
        }

        /* [2. 메인 컨테이너] */
        .image-container {
            position: relative;
            width: 1920px; 
            height: 1080px; 
            background-color: #f0f0f0; 
            overflow: hidden; 
        }

        /* [3. 공통 스타일] */
        .layer-img, .bg-img, .extra-img, .bubble-img {
            position: absolute;
            object-fit: contain;
            transition: transform 0.3s ease;
        }
        
        .layer-img:hover {
            transform: scale(1.05);
            cursor: pointer;
        }

        /* [배경 및 오브젝트 위치 수정 영역] */
        #bg1, #bg2, #bg3, #bg4 { width: 1920px; height: 1080px; top: 0; left: 0; }
        #bg1 { z-index: 1; }
        #bg2 { z-index: 2; }
        #bg3 { z-index: 3; }
        #bg4 { z-index: 4; }

        .extra-img { z-index: 5; pointer-events: none; }
        /* click 이벤트를 받기 위해 pointer-events를 auto로 변경할 수도 있지만, 
           여기서는 JS에서 대상을 잡기 위해 클래스 구조만 유지합니다. 
           (아래 JS에서 상호작용을 위해 필요한 요소는 pointer-events: auto 처리가 필요할 수 있음) 
           하지만 배경 요소라 클릭 통과가 자연스러우므로 hover 감지만 주로 동작합니다. */
        
        #bg5 { width: 150px; top: 100px; left: 100px; }
        #bg6 { width: 120px; top: 200px; left: 300px; }
        #bg7 { width: 180px; top: 150px; left: 1500px; }
        #bg8 { width: 100px; top: 800px; left: 200px; }
        #bg9 { width: 140px; top: 50px; left: 900px; }
        #bg10 { width: 100px; top: 900px; left: 1600px; }
        #bg11 { width: 100px; top: 10px; left: 10px; }
        #bg12 { width: 100px; top: 10px; left: 120px; }
        #bg14 { width: 100px; top: 10px; left: 340px; }
        
        /* [물방울 오브젝트] */
        .bubble-img { z-index: 6; pointer-events: auto; /* 상호작용을 위해 auto */ will-change: transform; }
        #bg13 { width: 60px; }
        #bg15 { width: 70px; }
        #bg16 { width: 50px; }
        #bg17 { width: 80px; }
        #bg18 { width: 55px; }
        #bg19 { width: 65px; }
        #bg20 { width: 60px; }

        /* 젤리 글리치 애니메이션 */
        @keyframes elastic-jelly {
            0% { transform: translateX(0) skewX(0) scale(1, 1); }
            30% { transform: translateX(-60px) skewX(-2deg) scale(0.95, 1.05); } 
            55% { transform: translateX(40px) skewX(1deg) scale(1.02, 0.98); }   
            75% { transform: translateX(-15px) skewX(-0.5deg) scale(1, 1); }
            100% { transform: translateX(0) skewX(0) scale(1, 1); }
        }
        .glitch-active {
            animation: elastic-jelly 0.8s cubic-bezier(0.25, 1.2, 0.5, 1) both;
            transition: none !important; 
        }

        /* [좌측 정보 텍스트] */
        #text-pos-container {
            position: absolute;
            top: 50%; transform: translateY(-50%);
            left: 70px; z-index: 9000;
            pointer-events: none; text-align: left;
            max-width: 1000px; word-break: keep-all;
        }
        .jagged-bg {
            background-color: #ffffff; color: #000000;            
            line-height: 1.6; padding: 5px 10px; 
            font-family: 'Wanted Sans Variable', sans-serif;
            font-weight: 700; font-size: 18px; 
            display: inline;
            -webkit-box-decoration-break: clone; box-decoration-break: clone;
            white-space: pre-wrap; 
            box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
        }
        .cursor::after {
            content: '|'; display: inline-block; margin-left: 2px; color: black;
            animation: blink 0.8s infinite; font-weight: 100;
        }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }

        /* [중앙 인물 Hannah] */
        .center-wrapper {
            position: absolute;
            width: 800px; height: 800px;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100; pointer-events: none; 
        }
        .center-wrapper img { pointer-events: auto; }

        #layer1 { width: 350px; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; }
        #layer1:hover { z-index: 11; }
        #layer2 { width: 350px; top: 415px; left: 225px; z-index: 20; }
        #layer2:hover { z-index: 21; }
        #layer3 { width: 95px; top: 270px; left: 400px; z-index: 30; }
        #layer3:hover { z-index: 31; }
        
        /* [화면 보호기] */
        #layer4 {
            position: absolute; width: 350px; top: 50%; left: 50%;
            transform: translate(-50%, -50%); object-fit: contain; 
            z-index: 999; opacity: 0; pointer-events: none; transition: opacity 2s ease-in-out;
        }
        #layer4.active { opacity: 1; }

        /* [호버 설명 텍스트] */
        #hover-description {
            position: absolute;
            top: 50%; left: 62%; transform: translateY(-50%);
            width: 450px; z-index: 9500; pointer-events: none; 
            opacity: 0; transition: opacity 0.3s ease;
        }
        #hover-description.visible { opacity: 1; }

        /* [푸터 자막] */
        #footer-text-container {
            position: absolute; top: 75%; left: 50%;
            transform: translateX(-50%); z-index: 9999;
            text-align: center; width: 100%; 
            pointer-events: auto; /* 상호작용(호버/클릭)을 위해 auto 설정 */
        }
        #footer-text {
            background-color: #ffffff; color: #000000;
            font-weight: 700; font-size: 20px;
            padding: 5px 15px;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
            transition: opacity 0.5s ease-in-out; opacity: 0; 
            cursor: pointer; /* 클릭 가능 표시 */
        }
        #footer-text.show { opacity: 1; }

        /* [음악용 iframe (숨김)] */
        #bg-music-frame {
            position: absolute; width: 0; height: 0;
            border: 0; visibility: hidden;
        }
    </style>
</head>
<body>
    
    <iframe id="bg-music-frame" 
            src="https://www.youtube.com/embed/fbR0t7CZ8X4?enablejsapi=1&autoplay=1&loop=1&playlist=fbR0t7CZ8X4&controls=0&showinfo=0&rel=0&mute=0" 
            allow="autoplay; encrypted-media"
            title="bgm">
    </iframe>

    <div class="image-container">
        <img src="bg1.png" id="bg1" class="bg-img" alt="Background 1" style="pointer-events: auto;">
        <img src="bg2.png" id="bg2" class="bg-img" alt="Background 2" style="pointer-events: auto;">
        <img src="bg3.png" id="bg3" class="bg-img" alt="Background 3" style="pointer-events: auto;">
        <img src="bg4.png" id="bg4" class="bg-img" alt="Background 4" style="pointer-events: auto;">

        <img src="bg5.png" id="bg5" class="extra-img" alt="Object 5" style="pointer-events: auto;">
        <img src="bg6.png" id="bg6" class="extra-img" alt="Object 6" style="pointer-events: auto;">
        <img src="bg7.png" id="bg7" class="extra-img" alt="Object 7" style="pointer-events: auto;">
        <img src="bg8.png" id="bg8" class="extra-img" alt="Object 8" style="pointer-events: auto;">
        <img src="bg9.png" id="bg9" class="extra-img" alt="Object 9" style="pointer-events: auto;">
        <img src="bg10.png" id="bg10" class="extra-img" alt="Object 10" style="pointer-events: auto;">
        <img src="bg11.png" id="bg11" class="extra-img" alt="Object 11" style="pointer-events: auto;">
        <img src="bg12.png" id="bg12" class="extra-img" alt="Object 12" style="pointer-events: auto;">
        <img src="bg14.png" id="bg14" class="extra-img" alt="Object 14" style="pointer-events: auto;">

        <img src="bg13.png" id="bg13" class="bubble-img" alt="Bubble 13" onerror="this.style.display='none'">
        <img src="bg15.png" id="bg15" class="bubble-img" alt="Bubble 15" onerror="this.style.display='none'">
        <img src="bg16.png" id="bg16" class="bubble-img" alt="Bubble 16" onerror="this.style.display='none'">
        <img src="bg17.png" id="bg17" class="bubble-img" alt="Bubble 17" onerror="this.style.display='none'">
        <img src="bg18.png" id="bg18" class="bubble-img" alt="Bubble 18" onerror="this.style.display='none'">
        <img src="bg19.png" id="bg19" class="bubble-img" alt="Bubble 19" onerror="this.style.display='none'">
        <img src="bg20.png" id="bg20" class="bubble-img" alt="Bubble 20" onerror="this.style.display='none'">

        <div id="text-pos-container">
            <span id="typing-target" class="jagged-bg cursor"></span>
        </div>

        <div id="hover-description"></div>

        <div class="center-wrapper">
            <img src="hannah1.png" id="layer1" class="layer-img" onclick="goToLink(1)" alt="Hannah 1">
            <img src="hannah2.png" id="layer2" class="layer-img" onclick="goToLink(2)" alt="Hannah 2">
            <img src="hannah3.png" id="layer3" class="layer-img" onclick="goToLink(3)" alt="Hannah 3">
            <img src="hannah4.png" id="layer4" alt="Screensaver">
        </div>

        <div id="footer-text-container">
            <span id="footer-text"></span>
        </div>
    </div>

    <script>
        // 1. 링크 이동
        function goToLink(layerNumber) {
            let url = "";
            if (layerNumber === 1) url = "https://www.google.com"; 
            else if (layerNumber === 2) url = "https://www.youtube.com"; 
            else if (layerNumber === 3) url = "https://elenakim0217.github.io/Golden-Indexed/"; 
            if (url) window.open(url, '_blank'); 
        }

        // 2. 화면 보호기
        let idleTimer;
        const screensaverLayer = document.getElementById('layer4');
        const idleLimit = 1 * 60 * 1000; 
        function showScreensaver() { if(screensaverLayer) screensaverLayer.classList.add('active'); }
        function resetTimer() {
            if(screensaverLayer) screensaverLayer.classList.remove('active');
            clearTimeout(idleTimer);
            idleTimer = setTimeout(showScreensaver, idleLimit);
        }

        // 3. [배경음악 강제 재생]
        let musicStarted = false;
        function forcePlayMusic() {
            if (!musicStarted) {
                const iframe = document.getElementById('bg-music-frame');
                const currentSrc = iframe.src;
                iframe.src = currentSrc; 
                musicStarted = true;
            }
        }

        // 4. [수정됨] 정보 텍스트 타이핑 효과 + 상호작용 리셋
        const typingText = `Human Protocol: Hannah
왜곡의 최대 경계선까지 나아가보자.
왜곡을 해체하고, 진실도 해체한다.
인간은 시각 정보 처리 능력에 의해
은폐되고, 편향된다.
명확하지만 싱겁고, 
간단명료하지만 미묘하게.
마치 교묘하게 비켜 가듯이.`;

        const typingTarget = document.getElementById('typing-target');
        let typeIndex = 0;
        let typingTimer = null;
        let loopTimer = null;

        // (1) 타이핑 실행 함수
        function runTyping() {
            if (typingTimer) clearTimeout(typingTimer); // 기존 타이핑 중단
            
            typeIndex = 0;
            if(typingTarget) typingTarget.textContent = "";
            
            typeWriter();
        }

        // (2) 글자 작성
        function typeWriter() {
            if (typingTarget && typeIndex < typingText.length) {
                typingTarget.textContent += typingText.charAt(typeIndex);
                typeIndex++;
                typingTimer = setTimeout(typeWriter, 50);
            }
        }

        // (3) 루프 시작 및 리셋 관리
        function startTypingLoop() {
            runTyping(); // 즉시 실행

            if (loopTimer) clearInterval(loopTimer); // 기존 루프 제거
            loopTimer = setInterval(runTyping, 10000); // 10초마다 반복 재예약
        }

        // (4) [NEW] 배경/자막 상호작용 시 타이핑 리셋
        function setupTypingInteractions() {
            // 배경 이미지(bg), 오브젝트(extra), 물방울(bubble), 푸터 컨테이너 선택
            const targets = document.querySelectorAll('.bg-img, .extra-img, .bubble-img, #footer-text-container');
            
            targets.forEach(el => {
                // 마우스 올리면 리셋
                el.addEventListener('mouseenter', startTypingLoop);
                // 클릭하면 리셋
                el.addEventListener('click', startTypingLoop);
            });
        }


        // 5. 호버 효과 & 푸터 오버라이드
        let isFooterOverride = false;
        function setupHoverEffects() {
            const layer1 = document.getElementById('layer1');
            const layer2 = document.getElementById('layer2');
            const layer3 = document.getElementById('layer3');
            const descBox = document.getElementById('hover-description');
            const footerText = document.getElementById('footer-text'); 

            const texts = {
                1: "Untouched,이은서 <br><br> 디지털 픽셀이 발명되기 훨씬 전부터 권력은 이미 역사를 '포토샵'하고 있었다. 스탈린의 에어브러시, 마오쩌둥의 덧칠... <br> 본 프로젝트는 허공에서 부유하는 조작된 이미지들을 통해 진실을 발굴한다.",
                2: "CONTROLLED SPECTRUM : 통제된 스펙트럼, 박지우 <br><br> 색은 생존과 직결된 '통제와 억압의 도구'다. 19세기의 맹독성 초록, 현대의 파란 스크린... <br> 아름다움 뒤에 은폐된 색의 권력 구조를 고발한다.",
                3: "Golden Indexed, 김채린 <br><br> ‘기호를 활용해 외계인과 소통할 수 있을까?’ <br> 인간 문명 속 무모한 낭만과 영감의 시너지를 주고자 한다."
            };
            const footerOverrides = {
                1: "Present", 
                2: "Past",    
                3: "Future"   
            };

            function onHover(layerId) {
                if(texts[layerId]) {
                    descBox.innerHTML = `<span class="jagged-bg">${texts[layerId]}</span>`;
                    descBox.classList.add('visible');
                }
                if(footerOverrides[layerId]) {
                    isFooterOverride = true; 
                    footerText.textContent = footerOverrides[layerId];
                    footerText.style.transition = 'none'; 
                    footerText.style.opacity = '1';       
                    footerText.classList.add('show');
                }
            }

            function onLeave() {
                descBox.classList.remove('visible');
                isFooterOverride = false; 
                footerText.style.transition = ''; 
                footerText.style.opacity = ''; 
                footerText.classList.remove('show'); 
            }

            if(layer1) { layer1.addEventListener('mouseenter', () => onHover(1)); layer1.addEventListener('mouseleave', onLeave); }
            if(layer2) { layer2.addEventListener('mouseenter', () => onHover(2)); layer2.addEventListener('mouseleave', onLeave); }
            if(layer3) { layer3.addEventListener('mouseenter', () => onHover(3)); layer3.addEventListener('mouseleave', onLeave); }
        }

        // 6. 배경 글리치 & 스크롤
        function startGlitchEffect() {
            const bgs = document.querySelectorAll('.bg-img'); 
            setInterval(() => {
                bgs.forEach(bg => {
                    bg.classList.add('glitch-active');
                    bg.addEventListener('animationend', () => {
                        bg.classList.remove('glitch-active');
                    }, { once: true });
                });
            }, 3000); 
        }
        function setupBackgroundScroll() {
            const bgs = document.querySelectorAll('.bg-img'); 
            let currentX = 0;
            let isScrolling;
            window.addEventListener('wheel', (e) => {
                const moveAmount = e.deltaY * -0.8; 
                currentX += moveAmount;
                if (currentX > 300) currentX = 300;
                if (currentX < -300) currentX = -300;
                bgs.forEach(bg => {
                    if (!bg.classList.contains('glitch-active')) {
                        const id = bg.id;
                        if (id === 'bg1' || id === 'bg3') bg.style.transform = `translateX(${currentX}px)`;
                        else if (id === 'bg2' || id === 'bg4') bg.style.transform = `translateX(${-currentX}px)`;
                    }
                });
                clearTimeout(isScrolling);
                isScrolling = setTimeout(() => {
                    currentX = 0;
                    bgs.forEach(bg => {
                        if (!bg.classList.contains('glitch-active')) {
                            bg.style.transition = 'transform 0.6s cubic-bezier(0.25, 1.2, 0.5, 1)'; 
                            bg.style.transform = 'translateX(0)';
                        }
                    });
                }, 60); 
            });
        }

        // 7. 물방울 물리 효과 (bg20 포함)
        function initBubbles() {
            const bubbleIds = ['bg13', 'bg15', 'bg16', 'bg17', 'bg18', 'bg19', 'bg20'];
            const bubbles = [];
            bubbleIds.forEach(id => {
                const el = document.getElementById(id);
                if(el && el.style.display !== 'none') {
                    const x = Math.random() * (1920 - 100);
                    const y = Math.random() * (1080 - 100);
                    const vx = (Math.random() - 0.5) * 4; 
                    const vy = (Math.random() - 0.5) * 4;
                    bubbles.push({
                        el: el, x: x, y: y, vx: vx, vy: vy,
                        width: el.clientWidth || 50, height: el.clientHeight || 50
                    });
                }
            });
            function update() {
                bubbles.forEach((b1, index) => {
                    b1.x += b1.vx; b1.y += b1.vy;
                    if (b1.x <= 0 || b1.x + b1.width >= 1920) {
                        b1.vx *= -1; b1.x = Math.max(0, Math.min(b1.x, 1920 - b1.width)); 
                    }
                    if (b1.y <= 0 || b1.y + b1.height >= 1080) {
                        b1.vy *= -1; b1.y = Math.max(0, Math.min(b1.y, 1080 - b1.height));
                    }
                    for (let j = index + 1; j < bubbles.length; j++) {
                        const b2 = bubbles[j];
                        const dx = (b1.x + b1.width/2) - (b2.x + b2.width/2);
                        const dy = (b1.y + b1.height/2) - (b2.y + b2.height/2);
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const minDistance = (b1.width/2 + b2.width/2) * 0.8; 
                        if (distance < minDistance) {
                            const tempVx = b1.vx; const tempVy = b1.vy;
                            b1.vx = b2.vx; b1.vy = b2.vy;
                            b2.vx = tempVx; b2.vy = tempVy;
                            const angle = Math.atan2(dy, dx);
                            const overlap = minDistance - distance;
                            b1.x += Math.cos(angle) * overlap / 2; b1.y += Math.sin(angle) * overlap / 2;
                            b2.x -= Math.cos(angle) * overlap / 2; b2.y -= Math.sin(angle) * overlap / 2;
                        }
                    }
                    b1.el.style.left = b1.x + 'px';
                    b1.el.style.top = b1.y + 'px';
                });
                requestAnimationFrame(update);
            }
            setTimeout(() => {
                bubbles.forEach(b => {
                   if(b.el.offsetWidth > 0) { b.width = b.el.offsetWidth; b.height = b.el.offsetHeight; }
                });
                update();
            }, 500);
        }

        // 8. 푸터 텍스트 롤링
        function startFooterRolling() {
            const footerEl = document.getElementById('footer-text');
            const messages = [
                'Hello, World.', 'This is Hannah.', 'Welcome to Human Protocol.',
                'What time zone are you from?', 'Or what era are you from?',
                'I come from all time and eras.', 'Would you like to join with me?'
            ];
            let index = 0;
            function showMessage() {
                if (isFooterOverride) return;
                footerEl.textContent = messages[index];
                footerEl.classList.add('show');
                setTimeout(() => { if (!isFooterOverride) footerEl.classList.remove('show'); }, 4000);
                index = (index + 1) % messages.length;
            }
            showMessage(); 
            setInterval(showMessage, 5000); 
        }

        // [초기화]
        window.onload = function() {
            resetTimer(); 
            setupHoverEffects(); 
            
            // 타이핑 관련 (자동 시작 + 상호작용 연결)
            startTypingLoop(); 
            setupTypingInteractions(); 

            startGlitchEffect(); 
            setupBackgroundScroll(); 
            startFooterRolling();
            initBubbles(); 
        };

        // [이벤트 리스너]
        function userInteracted() {
            resetTimer();
            forcePlayMusic(); 
        }

        document.onmousemove = userInteracted;
        document.onkeypress = userInteracted;
        document.ontouchstart = userInteracted;
        document.onclick = userInteracted;

    </script>
</body>
</html>